{"meta":{"title":"IIssWan's Notes","subtitle":"Quick notes","description":"这是一个假的程序猿","author":"wanWx","url":"http://wanWx.github.io"},"pages":[{"title":"","date":"2017-05-10T13:32:40.947Z","updated":"2017-05-10T03:23:15.146Z","comments":true,"path":"404.html","permalink":"http://wanWx.github.io/404.html","excerpt":"","text":""},{"title":"分类","date":"2017-05-10T02:41:11.000Z","updated":"2017-05-10T02:42:19.039Z","comments":true,"path":"categories/index.html","permalink":"http://wanWx.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-05-10T05:42:54.000Z","updated":"2017-05-10T05:51:27.024Z","comments":true,"path":"tags/index.html","permalink":"http://wanWx.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Flex 布局","slug":"flex-box","date":"2017-06-06T14:14:30.000Z","updated":"2017-06-06T15:46:12.809Z","comments":true,"path":"2017/06/06/flex-box/","link":"","permalink":"http://wanWx.github.io/2017/06/06/flex-box/","excerpt":"一、Flex布局是什么？Flex是Flexible Box的缩写，意为 “弹性布局”（PS: 说起弹性布局，就好气啊，面试的时候HR问：“说说弹性布局”,而我一脸懵逼！！）,就是用来为盒装模型提供最大的灵活性。任何一个容器都可以指定为Flex布局。123.box &#123; display: flex;&#125; 行内元素也可以使用Flex布局123.box &#123; display: inline-flex;&#125;","text":"一、Flex布局是什么？Flex是Flexible Box的缩写，意为 “弹性布局”（PS: 说起弹性布局，就好气啊，面试的时候HR问：“说说弹性布局”,而我一脸懵逼！！）,就是用来为盒装模型提供最大的灵活性。任何一个容器都可以指定为Flex布局。123.box &#123; display: flex;&#125; 行内元素也可以使用Flex布局123.box &#123; display: inline-flex;&#125; Webkit 内核的浏览器，必须加上-webkit前缀。1234.box &#123; display: -webkit-flex; /* Safari */ display: flex;&#125; 1、flex布局基本概念（~~ 可能有点老掉牙了，但是很有用啊）在使用了Flex布局的元素，称为Flex容器，简称“容器”。它的所有子元素自动成为容器的成员，称为Flex项目（自我理解就是一个容器的放了很多小块，这些小块都归外面的容器爸爸管） 2、容器的属性2.1 flex-direction属性flex-direction属性觉得主轴的方向(即项目的排列方向)。123.box &#123; flex-direction: row | row-reverse | column | column-reverse;&#125; 分别有4个值 row（默认值）：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿。 2.2 flex-wrap属性默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。它可能取三个值。（1）nowrap（默认）：不换行。（2）wrap：换行，第一行在上方。（3）wrap-reverse：换行，第一行在下方。 2.3 flex-flowflex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。123.box &#123; flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;&#125; 2.4 justify-content属性justify-content属性定义了项目在主轴上的对齐方式。它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。 flex-start（默认值）：左对齐 flex-end：右对齐 center： 居中 space-between：两端对齐，项目之间的间隔都相等。 space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 2.5 align-items属性align-items属性定义项目在交叉轴上如何对齐。123.box &#123; align-items: flex-start | flex-end | center | baseline | stretch;&#125; 它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。 flex-start：交叉轴的起点对齐。 flex-end：交叉轴的终点对齐。 center：交叉轴的中点对齐。 baseline: 项目的第一行文字的基线对齐。 stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 2.6 align-content属性align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。123.box &#123; align-content: flex-start | flex-end | center | space-between | space-around | stretch;&#125; 该属性可能取6个值。 flex-start：与交叉轴的起点对齐。 flex-end：与交叉轴的终点对齐。 center：与交叉轴的中点对齐。 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch（默认值）：轴线占满整个交叉轴。 项目的属性以下6个属性设置在项目上。 order flex-grow flex-shrink flex-basis flex align-self order属性order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。123.item &#123; order: &lt;integer&gt;;&#125; 4.2 flex-grow属性flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。123.item &#123; flex-grow: &lt;number&gt;; /* default 0 */&#125; 如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 4.3 flex-shrink属性flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。123.item &#123; flex-shrink: &lt;number&gt;; /* default 1 */&#125; 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。","categories":[{"name":"CSS","slug":"CSS","permalink":"http://wanWx.github.io/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://wanWx.github.io/tags/CSS/"}]},{"title":"vue基础知识-事件监听","slug":"20170601","date":"2017-06-01T14:45:34.000Z","updated":"2017-06-01T15:22:12.738Z","comments":true,"path":"2017/06/01/20170601/","link":"","permalink":"http://wanWx.github.io/2017/06/01/20170601/","excerpt":"事件监听你可以使用v-on指令来绑定并监听 DOM 事件。绑定的内容可以是一个当前实例上的方法 (后面无需跟括号) 或一个内联表达式。如果提供的是一个方法，则原生的 DOM event 会被作为第一个参数传入，同时这个 event 会带有 targetVM属性，指向触发该事件的相应的 ViewModel：","text":"事件监听你可以使用v-on指令来绑定并监听 DOM 事件。绑定的内容可以是一个当前实例上的方法 (后面无需跟括号) 或一个内联表达式。如果提供的是一个方法，则原生的 DOM event 会被作为第一个参数传入，同时这个 event 会带有 targetVM属性，指向触发该事件的相应的 ViewModel：1234&lt;div id=&quot;demo&quot;&gt; &lt;a v-on=&quot;click: onClick&quot;&gt;触发一个方法函数&lt;/a&gt; &lt;a v-on=&quot;click: n++&quot;&gt;触发一个表达式&lt;/a&gt;&lt;/div&gt; 123456789101112new Vue(&#123; el: &apos;#demo&apos;, data: &#123; n: 0 &#125;, methods: &#123; onClick: function (e) &#123; console.log(e.target.tagName) // &quot;A&quot; console.log(e.targetVM === this) // true &#125; &#125;&#125;) 执行表达式当在v-repeat 里使用v-on时，targetVM显得很有用，因为 v-repeat会创建大量子 ViewModel。但是，通过执行表达式的方式，把代表当前 ViewModel 数据对象的别名传进去，会更方便直观一些：12345&lt;ul id=&quot;list&quot;&gt; &lt;li v-repeat=&quot;item in items&quot; v-on=&quot;click: toggle(item)&quot;&gt; &#123;&#123;item.text&#125;&#125; &lt;/li&gt;&lt;/ul&gt; 1234567891011121314new Vue(&#123; el: &apos;#list&apos;, data: &#123; items: [ &#123; text: &apos;one&apos;, done: true &#125;, &#123; text: &apos;two&apos;, done: false &#125; ] &#125;, methods: &#123; toggle: function (item) &#123; item.done = !item.done &#125; &#125;&#125;) 为什么要在 HTML 中写监听器？你可能会注意到整个事件监听的方式违背了 “separation of concern” 的传统理念。不必担心，因为所有的 Vue.js 时间处理方法和表达式都严格绑定在当前视图的 ViewModel 上，它不会导致任何维护困难。实际上，使用 v-on 还有更多好处： 它便于在 HTML 模板中轻松定位 JS 代码里的对应方法实现。 因为你无须在 JS 里手动绑定事件，你的 ViewModel 代码可以是非常纯粹的逻辑，和 DOM 完全解耦。这会更易于测试。 当一个 ViewModel 被销毁时，所有的事件监听都会被自动移除。你无须担心如何自行清理它们。","categories":[{"name":"vue","slug":"vue","permalink":"http://wanWx.github.io/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://wanWx.github.io/tags/vue/"}]},{"title":"因为她不喜欢你啊","slug":"firstblogg","date":"2017-05-14T02:55:31.000Z","updated":"2017-05-14T04:52:17.089Z","comments":true,"path":"2017/05/14/firstblogg/","link":"","permalink":"http://wanWx.github.io/2017/05/14/firstblogg/","excerpt":"她不理你是对的，是为了你好，这个人不喜欢你，回应你只会害你陷得更深，事实上她还是不喜欢你，你会更伤心的。","text":"她不理你是对的，是为了你好，这个人不喜欢你，回应你只会害你陷得更深，事实上她还是不喜欢你，你会更伤心的。 心这个东西并不是你想要就能得到的，也不是你喜欢就该是你的，你伤心怎么怎么样…这些都是你的事情，和那个人没关系.","categories":[{"name":"随笔","slug":"随笔","permalink":"http://wanWx.github.io/categories/随笔/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://wanWx.github.io/tags/随笔/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-05-10T13:32:41.052Z","updated":"2017-05-16T15:12:59.673Z","comments":true,"path":"2017/05/10/hello-world/","link":"","permalink":"http://wanWx.github.io/2017/05/10/hello-world/","excerpt":"之前一直想搭建属于自己的一个博客，但因为各种原因都不了了之(总要是懒),恰好最近比较闲，于是偷偷自己按网上资料，搭建了属于自己的博客。 至于为什么要自己搭建自己的博客…","text":"之前一直想搭建属于自己的一个博客，但因为各种原因都不了了之(总要是懒),恰好最近比较闲，于是偷偷自己按网上资料，搭建了属于自己的博客。 至于为什么要自己搭建自己的博客… hhhh,大概是为了装逼，同时自己搭建博客的话，样式的选择也比较自由，可以自己选择，不需要受限于各大平台。 好了，话就这么多…","categories":[{"name":"公告","slug":"公告","permalink":"http://wanWx.github.io/categories/公告/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://wanWx.github.io/tags/vue/"},{"name":"随笔","slug":"随笔","permalink":"http://wanWx.github.io/tags/随笔/"},{"name":"CSS","slug":"CSS","permalink":"http://wanWx.github.io/tags/CSS/"},{"name":"Javascript","slug":"Javascript","permalink":"http://wanWx.github.io/tags/Javascript/"},{"name":"Html","slug":"Html","permalink":"http://wanWx.github.io/tags/Html/"}]}]}